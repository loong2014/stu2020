package com.sunny.module.stu.AJAVA.H垃圾回收GC;

import com.sunny.module.stu.base.StuImpl;

/*
https://blog.csdn.net/laomo_bible/article/details/83112622
 */
public class Stu常用算法 extends StuImpl {

    @Override
    public void a_是什么() {
        //GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。
        标记_清除算法();

        标记_压缩算法();

        复制算法();

        分代收集算法();
    }

    private void 标记_清除算法() {
        //标记-清除算法
        /*
        为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。
        分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；
        第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。

优点
最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，
找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。

缺点
它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；
所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。

         */
    }

    private void 标记_压缩算法() {

        //  标记-压缩算法（标记-整理）
        /*
        标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；
        不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，
        然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。

优点
该算法不会像标记-清除算法那样产生大量的碎片空间。

缺点
如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。
         */
    }

    private void 复制算法() {
        // 复制算法
        /*
        该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，
        将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。
            这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。

优点
实现简单；不产生内存碎片

缺点
每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。
         */

    }

    private void 分代收集算法() {
        // 分代收集算法
        /*
        现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。
        在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用【复制算法】。
             具体过程：新生代(Young)分为Eden区，From区与To区
             1、当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。
             一般来说这时候不是所有的对象都没用了，所以就会把【Eden区】还能用的对象复制到【From区】。
             2、这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，
             然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将【Eden区】与【From区】还在被使用的对象复制到【To区】，
             3、再下一次YoungGC的时候，则是将【Eden区】与【To区】中的还在被使用的对象复制到【From区】。
             4、经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），
             这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。

        老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

        老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。
        如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。
         */
    }

}
