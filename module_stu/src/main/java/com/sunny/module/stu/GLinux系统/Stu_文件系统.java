package com.sunny.module.stu.GLinux系统;

import com.sunny.module.stu.base.StuImpl;

/*
https://cloud.tencent.com/developer/article/1671947?from=14588
 */
public class Stu_文件系统 extends StuImpl {

    @Override
    public void a_是什么() {
        /*
        用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作都是依靠文件系统来完成的。
            Linux 系统支持数十种的文件系统，而最常见的文件系统如下所示。

        Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。
            然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。
            会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。

        Ext4：Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，
            它支持的存储容量高达 1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。
            另外，Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。

        XFS：是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，
            即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。
            并且它最大可支持的存储容量为 18EB，这几乎满足了所有需求。
         */
        /*

        为了使用户在读取或写入文件时不用关心底层的硬盘结构，Linux 内核中的软件层为用户程序
            提供了一个 VFS（Virtual File System，虚拟文件系统）接口，
            这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。
         */
    }

    @Override
    public void s_数据结构() {

        // 万物皆文件
        /*
            在unix里，“一切皆为文件”，设备也会被视为文件。
                包括 网络连接套接字、管道
         */

        /*
            扇区(Sector)：磁盘的最小存储单位。
                硬盘的最小【存储】单位，每个扇区储存512字节（相当于0.5KB）

                其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。


            块(Block)：文件系统读写数据的最小单位。
                一个磁盘块由连续几个（2^n）扇区组成。最常见的是4KB（既连续八个sector组成一个block）
                对于文件管理来说，每个文件对应的多个block可能是不连续的；一个文件至少占用一个块；

            段(Section)：是Linux内存管理机制中一个内存页或者内存页的一部分。
                由若干个连续的块组成

            页(Page)：内存映射的最小单位。
                是内核内存映射管理的基本单位。linux内核的页式内存映射名称来源于此。

            内存的最小存储单位。
                页的大小为磁盘块大小的2^n倍

            索引节点(inode)：存储文件【元信息】，包括文件数据block的位置

            inode号码：每个inode都有一个号码，操作系统用inode号码来识别不同的文件。

            目录(directory)：目录项列表
                目录项：文件的文件名，以及该文件名对应的inode号码

            文件描述符(fd)：文件描述符是一个抽象的用于访问文件或者其他输入输出资源一个指示符。

            inode table：存储inode信息

         */

        // 文件系统如何取文件
        /*
        1、根据文件名，通过Directory里的对应关系，找到文件对应的Inode number
        2、再根据Inode number读取到文件的Inode table
        3、再根据Inode table中的Pointer读取到相应的Blocks
         */


        // mount
        /*
        将文件系统和存储设备联系起来的方法：挂载(mounting)。
        mount命令通常被用于将文件系统和当前文件目录级别联系起来。
            在mount过程中需要提供文件系统类型、文件系统、挂载点。

            第一步：基于当前文件系统中的文件创建一个文件系统file256mb.img
                    (file256mb.img对于当前文件系统来说是一个文件)。
                dd if=/dev/zero of=file256mb.img bs=4k count=65536

            第二步：使用mke2fs在file265mb.img上创建文件系统
                    (从file256mb.img自身角度来说，他是一个文件系统了)
                mke2fs -t ext4 -c file265mb.img

            第三步：创建一个挂载点
                    (从当前系统角度来说，他就是一个目录，一个文件；
                    但是从即将要挂在文件系统的角度来说，他就是一个存储设备)
                mkdir /path/to/mount/point

            第四步：将文件系统挂载到当前文件级别
                    (将文件系统和存储设备关联起来)
                mount -t ext4 file256mb.img /path/to/point
         */
    }

    /*
    https://cloud.tencent.com/developer/article/1671947?from=14588
     */
    private void stu_扇区() {
        /*
        硬盘设备是由大量的扇区组成的，每个扇区的容量为 512 字节。
            其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。
            就第一个扇区来讲，
                主引导记录需要占用 446 字节，
                分区表为 64 字节，
                结束符占用 2 字节；

            其中分区表中每记录一个分区信息就需要 16 字节，这样一来最多只有 4 个分区信息可以写到第一个扇区中，
                这 4 个分区就是 4 个主分区。

            为了解决分区个数不够的问题，可以将第一个扇区的分区表中 16 字节（原本要写入主分区信息）的空间（称之为扩展分区）
                拿出来指向另外一个分区。

            扩展分区其实并不是一个真正的分区，而更像是一个占用 16 字节分区表空间的指针——一个指向另外一个分区的指针。

            这样一来，用户一般会选择使用 3 个主分区加 1 个扩展分区的方法，
                然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于 4 个）的需求。
         */
    }

}
