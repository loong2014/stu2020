package com.sunny.module.stu.A基础知识

/**
 * https://juejin.cn/post/6972434953912975374?searchId=202401111532106BA1AFE740EE9D9A8141
 * Kotlin是一种在Java虚拟机（JVM）上运行的静态类型编程语言，
 * 因此，Kotlin和Java共享相同的内存模型。
 */
class A内存模型 {
    // 当一个进程启动后，系统会给进程分配一块内存区域【运行时数据区】
    // JVM的内存模型，就是将这块区域进行职能划分：

    // 堆
    // 方法区
    // 虚拟机栈
    // 本地方法栈
    // 程序技术器

    /**
     * 程序计数器（Program Counter Register）
     * 线程私有
     * 当前线程所执行的字节码的行号指示器
     */
    private fun 程序技术器() {
        /*
        它可以看作是当前线程所执行的字节码的行号指示器。
        字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
        它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

        由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，
        在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。
        因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，
        我们称这类内存区域为“线程私有”的内存。
         */
    }

    /**
     * 线程私有
     * Java方法的执行，对应一个栈帧的入栈到出栈的过程
     */
    private fun 虚拟机栈() {
        /*
        与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。
        Java虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，
        用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
        每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
         */

        // 栈帧 是方法调用和方法执行的数据结构
        /*
        1、局部变量表：是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量
            读取方法表中 Code_attribute 的 max_locals 字段(确定大小)，生成变量表
            变量表的存储单位是 变量槽(slot)：一个slot可以存放32位以内的数据

            虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。
            局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。
            其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

        2、操作数栈：是一个先进后出栈
            读取方法表中 Code_attribute 的 max_stacks 字段(确定栈大小)，生成操作数栈

            操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

            方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。

            操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，例如iadd指令，不能出现一个long和一个float使用iadd命令相加的情况。

        3、动态链接：指向所属方法的引用
            每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中 的动态连接。
            Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为 参数。
            这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静 态解析。
            另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

        // 方法返回地址
            恢复上层方法的局部变量表和操作数栈
            把返回值压入调用者栈帧的操作数栈
            调整pc计数器的值，指向方法调用指令，后面的指令
         */
    }

    /**
     * 本地方法栈（Native Method Stacks）
     * 线程私有
     * Native方法的执行
     */
    private fun 本地方法栈() {
        /*
        本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，
        其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
         */
    }

    /**
     * 线程共享
     * 存放对象实例
     */
    private fun 堆() {
        /*
        Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，
        Java世界里“几乎”所有的对象实例都在这里分配内存。

        实体对象，可以被【栈】中的局部变量引用
        可以被【方法区】的静态变量引用
        可以被其它实体对象的变量引用
         */

        // 当对象不再被引用时，则会被gc回收
        /*
        新生代——Eden + Survivor1 + Survivor2
        老年代——在Survivor中存活一定次数的对象
        jdk1.7永久代——主要保存class,method,filed对象
        jdk1.8元空间——所占用的内存空间不是在虚拟机内部，而是在本地内存空间中
         */
        // 如果没有指定堆内存大小，默认初始堆内存为物理内存的1/64，最大不超过物理内存的1/4或1G。
        // 注意的是元空间会自动扩容，默认情况下不受限制。

    }

    /**
     * 线程共享
     * 存储类信息，常量，静态变量
     */
    private fun 方法区() {
        // 类的class对象
        /*
        方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，
        它用于存储已被虚拟机加载的类信息、 常量、静态变量、即时编译器编译后的代码缓存等数据。
         */
    }
}