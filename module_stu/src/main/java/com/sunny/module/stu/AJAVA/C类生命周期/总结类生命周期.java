package com.sunny.module.stu.AJAVA.C类生命周期;

import com.sunny.module.stu.base.StuImpl;

/*
https://blog.csdn.net/static_zh/article/details/100084370
 */
public class 总结类生命周期 extends StuImpl {

    @Override
    public void a_是什么() {
        // 加载
        /*
        加载过程主要做了三件事：
        1）通过类的全限定名来获取定义此类的二进制字节流
        2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        3）在内存中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的方位入口。

        第一步主要是获取一个类的二进制字节流，意思就是把类以流的形式加载进内存，类的来源没有说，
        可以是jar包，也可以是class文件或者是apk文件。这个特性是能够实现插件化技术的理论基础。

        第二步就是在获取到这个字节流以后，虚拟机就会把类中的静态存储结果保存到方法区中，
        保存的过程会转化对应方法区中的数据结构，所以说静态的结构都保存在内存中的方法区中。

        第三步是当类加载进内存以后，每个类都会生成一个对应的Class对象，当我们使用这个类的时候，
        都是通过此Class对象为入口来使用的，
        比如我们写程序的时候通过 new 关键字创建一个类的对象的时候，也是通过这个类的Class对象来创建的。
         */

        // 链接
        //连接阶段主要分 验证、准备和解析。

        //验证：主要是对类中的语法结构是否合法进行验证，确认类型符合Java语言的语义。
        //准备：这个阶段是给类中的类变量分配内存，设置默认初始值，比如一个静态的int变量初始值是0，布尔变量初始值是false。
        //解析：在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。
        //解析的过程可能不好理解，关于符号引用和直接引用是什么意思可以暂时忽略，
        //
        // 这个过程可以理解为一开始虚拟机对加载到内存中的各种类、字段等并没有一一编号，只是通过一个符号去表示，在解析阶段，虚拟机把内存中的类、方法等进行统一管理起来。


        // 1、验证
            /*
            主要是对类中的语法结构是否合法进行验证，确认类型符合Java语言的语义
                格式验证
                语义验证
                操作验证
             */

        // 2、准备
            /*
                这个阶段是给类中的类变量分配内存，设置【默认初始值】，比如一个静态的int变量初始值是0，布尔变量初始值是false。
                如果是final类型的静态变量，则进行【显式的赋值】
             */

        // 3、解析
            /*
                将【常量池】中的【符号引用】替换为【直接引用】
                在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。
                    这个过程可以理解为一开始虚拟机对加载到内存中的各种类、字段等并没有一一编号，只是通过一个符号去表示，
                    在解析阶段，虚拟机把内存中的类、方法等进行统一管理起来。

                【符号引用】：
                    符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。
                    例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。
                    符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。
                    在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。
                    比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，
                    因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。
                    各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

                【直接引用】：
                    （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
                    （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
                    （3）一个能间接定位到目标的句柄
             */

        // 初始化
        /*
            初始化阶段才真正到了类中定义的java代码的阶段，在这个阶段会对类中的变量和一些代码块进行初始化，
            比如以类变量进行初始化，在【准备】阶段对类变量进行的【默认初始化】，到这个阶段就对对变量进行【显式的赋值】，
            其中【静态代码块】就是在这个阶段来执行的。

            初始化不会马上执行，当一个类被【主动使用】的时候才会去初始化，主要有下面这几种情况：

            // 主动使用
                1）当创建某个类的新实例时（如通过new或者反射等）
                2）当调用某个类的静态方法时
                3）当使用某个类或接口的静态字段时
                4）当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时
                5）当初始化某个子类时
         */
        /*
            关于类的加载过程就是上面这几步，分析完以后可以知道，我们程序员能够控制的只有第一步「加载」还有最后一步「初始化」，
            第一步加载的理论基础决定了插件化可以实现，
            最后一步初始化就是执行我们实际程序中的代码。
         */

        // 使用
        // 主动引用
                /*
                1、new
                2、调用 static 变量/方法
                3、反射
                4、初始化子类
                 */
        // 被动引用
                /*
                1、调用父类 static 变量/方法，不会引起子类初始化
                2、调用static final 变量
                3、定义类数组
                 */


        // 卸载
        // GC
    }
}
