package com.sunny.module.stu.D设计模式.结构型.A代理模式;

import com.sunny.module.stu.base.StuImpl;


public class Stu代理模式 extends StuImpl {

    /*
    https://www.cnblogs.com/whirly/p/10154887.html
     */
    @Override
    public void a_是什么() {
        // 给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问
        // 静态代理 编译期确定真实对象的范围，在运行期之前就已经加载了真实对象
        // 动态代理 运行期，动态加载真实对象，没有范围限制
    }

    @Override
    public void s_数据结构() {
        //代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层
        // 代理模式角色分为 3 种：
/*

        Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；

        RealSubject（真实主题角色）：真正实现业务逻辑的类；

        Proxy（代理主题角色）：用来代理和封装真实主题；
 */

    }

    @Override
    public void c_功能() {
        // 如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：
        // 静态代理
        /*
        所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。

        通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。

        虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。

            1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
                只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大
                新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类

            2、 当接口需要增加、删除、修改方法的时候，【目标对象】与【代理类】都要同时修改，不易维护。

         */

        // 动态代理
        /*
        而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件

        当然是让代理类动态的生成啦，也就是动态代理。

         */


    }
}
