package com.sunny.module.stu.BAndroid.A进程间通信;

import com.sunny.module.stu.base.StuImpl;

public class Stu进程间通信 extends StuImpl {

    @Override
    public void a_是什么() {
        // 两个进程进行数据交互

        // 虚拟内存空间，物理内存空间
        /*
            物理内存空间：
                真实存在的内存空间。比如内存是4G，那你的物理内存大小就是4G。

            虚拟内存空间：
                对物理内存空间的映射。理论上一块物理内存空间，可以对应多个虚拟内存空间。
         */

        // 内存空间划分：用户空间，内核空间
        /*
            内核空间：
                系统服务运行的空间，比如Binder驱动就运行在内核空间。

            用户空间：
                应用程序运行的空间，每个应用进程都有一块单独的用户空间。
                    JVM进一步将这块进程独有的用户空间，再次划分为 堆区，方法区，栈区
         */

        // 为了系统安全，操作系统不允许，用户空间相互访问，因此如果要完成进程间的交互，需要借助内核空间


        // Binder 通信的原理
        /*
            1、Binder 驱动在【内核空间】创建一个【数据接收缓存区】
            2、接着在【内核空间】开辟一块【内核缓存区】，建立【内核缓存区】和内核中【数据接收缓存区】之间的映射关系
                以及内核中【数据接收缓存区】和【接收进程】用户空间地址的映射关系
            3、【发送进程】通过系统调用 copyfromuser()，将用户空间中的数据 copy 到内核中的【内核缓存区】，
                由于【内核缓存区】和【接收进程】的用户空间存在映射，因此也就相当于把数据发送到了【接收进程】的用户空间，
                这样就完成了一次进程间通信。
         */

        // 这里有几个疑问？
        /*
            1、用户空间是如何将数据拷贝到内核空间的？
                借助系统函数：ioctl(copyfromuser)
            2、如何将物理空间的 "abc"，映射到虚拟空间？
                同样是系统函数：mmap
            3、是如何将进程B的处理结果，返回给进程A的？
                进程B同样需要将自己处于用户空间的数据 "result"，拷贝一份到内核空间，再通知进程A读取结果数据
         */

        // Binder 通信中真正繁忙的不是Binder驱动，而是另一个处于用户空间的服务 ServiceManger
        /*
            ServiceManger：可以理解为Binder的管理者，管理着存储在内核空间的binder节点

         */

    }
}
